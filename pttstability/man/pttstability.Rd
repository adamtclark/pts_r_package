% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pttstability_man.R
\docType{package}
\name{pttstability}
\alias{pttstability}
\alias{pttstability-package}
\title{pttstability: A package for fitting state space models using EDM.}
\source{
Knape, J., and Valpine, P. (2012). Fitting complex population models by combining particle filters with Markov chain Monte Carlo. Ecology 93:256-263.

Ye, H., Sugihara, G., et al. (2015). Equation-free ecosystem forecasting. PNAS 112:E1569-E1576.

Ye, H., et al. (2019). rEDM: Applications of Empirical Dynamic Modeling from Time Series. R package version 0.7.2.

Hartig, F., et al. (2019). BayesianTools: General-Purpose MCMC and SMC Samplers and Tools for Bayesian Statistics. R package version 0.1.6.
}
\description{
The pttstability (or "ParTicle-Taylor Stability" package) is a collection of functions
that can be used to estimate the parameters of a stochastic state space model (i.e.
a model where a time series is observed with error).
}
\section{Applications}{


The goal of this package is to estimate the variability around a deterministic process, both in terms of
observation error - i.e. variability due to imperfect observations that does not influence system state -
and in terms of process noise - i.e. stochastic variation in the actual state of the process.
Unlike classical methods for estmiating variability, this package does not necesarilly assume that
the deterministic state is fixed (i.e. a fixed-point equilibrium), meaning that variability around a
dynamic trajectory can be estimated (e.g. stochastic fluctuations during predator-prey dynamics).

By combining information about both the estimated deterministic state of the system and the estimated
effects of process noise, this package can be used to compute a dynamic analog of various stability metrics
 - e.g. coefficient of variation (CV) or invariability. Estimated extinction rates and colonization rates
 can also be estimated.
}

\section{Contents}{


This package builds on three existing toolkits. First, it applies an updated version of the
"particleFilterLL" particle filter function of Knape and Valpine (2012) to calculate likelihoods of
observed time series given modeled dynamics.
Second, it applies empirical dynamic modeling (EDM) methods from the rEDM package to estimate deterministic
dynamics even in cases where the underlying equations governing system behavior are not known.
Finally, it uses the MCMC fitting methods from the BayesianTools package to estimate paramter values for
the observation error, process noise, and (optionally) deterministic functions underlying observed dynamics.

The default observation error and process noise functions in this package (obsfun0 and procfun0)
take advantage of the Taylor Power law to separate noise components for relatively short time series,
from which the name of this package is derived.
Process noise is assumed to scale with the magnitude of the observed state as a power function sd_proc(x) = a*x^z,
whereas observation error is assumed to scale linearly, i.e. sd_obs(x) = b + c*x.

Note that although we include default functions in this package, users are able (and encouraged!) to write
their own (including for observation error, process noise, deterministic dynamics, priors, and likelihoods).
}

\examples{
## Simulate data
pars<-list(obs=c(log(1e-2), log(0.1)),
           proc=c(-2, log(1.2)),
           pcol=c(logit(0.2), log(1e-2)),
           det=c(log(3),log(1)))

datout<-makedynamics(n = 100, obs = pars$obs, proc = pars$proc, r = pars$det[1],
                     K = pars$det[2], pcol = pars$pcol)
y<-datout$obs


## Run filter
N = 1e3
#based on detful0
filterout_det<-particleFilterLL(y, pars=pars, N, detfun = detfun0, dotraceback = TRUE)
#based on EDM
filterout_edm<-particleFilterLL(y, pars=pars, N, detfun = EDMfun0, edmdat = list(E=2),
                                dotraceback = TRUE)

#plot filter output
par(mar=c(4,4,2,2), mfrow=c(3,1))
matplot(1:length(y), t(filterout_det$x)[,1:30], col=adjustcolor(1,alpha.f = 0.5), lty=3,
        type="l", xlab="time", ylab="abund", main="detfun0")
lines(1:length(y), y, col=2, lwd=1.5)
lines(1:length(y), datout$true, col="blue", lwd=1.5, lty=2)
lines(1:length(y), filterout_det$rN, col=3, lwd=1.5)

matplot(1:length(y), t(filterout_edm$x)[,1:30], col=adjustcolor(1,alpha.f = 0.5), lty=3,
        type="l", xlab="time", ylab="abund", main="EDM")
lines(1:length(y), y, col=2, lwd=1.5)
lines(1:length(y), datout$true, col="blue", lwd=1.5, lty=2)
lines(1:length(y), filterout_edm$rN, col=3, lwd=1.5)

plot(filterout_det$rN, y, xlim=range(c(filterout_det$rN, filterout_edm$rN)),
     xlab="predicted", ylab="observed", col=4); points(filterout_edm$rN, y, col=2)
abline(a=0, b=1, lty=2)
legend("topleft", c("detfun0", "EDM"), pch=1, col=c(4,2), bty="n")


## Run optimizer
\dontrun{
param<-unlist(pars)[1:6]

#create priors
density_fun_USE<-function(param) density_fun0(param = param, pars = pars)
sampler_fun_USE<-function(x) sampler_fun0(n = 1, pars = pars)
prior <- createPrior(density = density_fun_USE, sampler = sampler_fun_USE,
                     lower = rep(-10,6), upper = rep(10,6))

likelihood0(param, y = y)+density_fun_USE(param)
likelihood0(param, y=y, detfun = EDMfun0, edmdat = list(E=2))+density_fun_USE(param)

#plot priors
tmp<-inv_fun0(sampler_fun0(1e4,pars = pars))
hist(tmp[,1], breaks = 30); abline(v=exp(pars$obs[1]), col=2, lwd=2, lty=2)
hist(tmp[,2], breaks = 30); abline(v=exp(pars$obs[2]), col=2, lwd=2, lty=2)
hist(tmp[,3], breaks = 30); abline(v=(pars$proc[1]), col=2, lwd=2, lty=2)
hist(tmp[,4], breaks = 30); abline(v=exp(pars$proc[2]), col=2, lwd=2, lty=2)
hist(tmp[,5], breaks = 30); abline(v=ilogit(pars$pcol[1]), col=2, lwd=2, lty=2)
hist(tmp[,6], breaks = 30); abline(v=exp(pars$pcol[2]), col=2, lwd=2, lty=2)

#number of MCMC iterations - increase for more accurate results
#note - runtime will be long for EDM example
niter<-501
nburn<-102

#with detfun0
likelihood_detfun0<-function(x) likelihood0(param=x, y=y, parseparam = parseparam0)
bayesianSetup_detfun0 <- createBayesianSetup(likelihood = likelihood_detfun0, prior = prior)
out_detfun0 <- runMCMC(bayesianSetup = bayesianSetup_detfun0,
                       settings = list(iterations=niter, burnin=nburn))

#with EDM
likelihood_EDM<-function(x) likelihood0(param = x, y=y, parseparam = parseparam0,
  detfun = EDMfun0, edmdat = list(E=2))
bayesianSetup_EDM <- createBayesianSetup(likelihood = likelihood_EDM, prior = prior)
out_EDM <- runMCMC(bayesianSetup = bayesianSetup_EDM,
                   settings = list(iterations=niter, burnin=nburn))


## Summarize outputs
smp_detfun0<-inv_fun0(getSample(out_detfun0))
smp_EDM<-inv_fun0(getSample(out_EDM))

plot(data.frame(smp_detfun0))
plot(data.frame(smp_EDM))

#plot posteriors
truepars_transformed<-inv_fun0(t(as.matrix(unlist(pars))))

par(mar=c(4,4,2,2), mfrow=c(3,2))
for(i in 1:6) {
  hist(smp_detfun0[,i],breaks = 30); abline(v=truepars_transformed[i], col=c(2), lty=2)
}

for(i in 1:6) {
  hist(smp_EDM[,i],breaks = 30); abline(v=truepars_transformed[i], col=c(2), lty=2)
}

## Plot demographic rates
pfout_detfun0<-particleFilterLL(y, pars=pars, N, detfun = detfun0, dotraceback = TRUE)
pfout_EDM<-particleFilterLL(y, pars=pars, N, detfun = EDMfun0, edmdat = list(E=2),
                            dotraceback = TRUE)

par(mar=c(4,4,2,2), mfrow=c(2,1))
matplot(1:nrow(pfout_detfun0$dem$col),
        cbind(pfout_detfun0$dem$col[,1]/pfout_detfun0$dem$col[,2],
              pfout_EDM$dem$col[,1]/pfout_EDM$dem$col[,2]),
        pch=1, col=c(2,4), xlab="time", ylab="pr[col]")
matplot(1:nrow(pfout_detfun0$dem$col),
        cbind(pfout_detfun0$dem$mor[,1]/pfout_detfun0$dem$mor[,2],
              pfout_EDM$dem$mor[,1]/pfout_EDM$dem$mor[,2]),
        pch=1, col=c(2,4), xlab="time", ylab="pr[ext]")
}
}
