#' Parse parameters
#'
#' Takes in a vector of 3 or 6 parameters, and puts them into a list of the format expected by the particleFilterLL function.
#' @param param List of 3 or 6 paramters, in the order (obs1, proc1, pcol1, pcol2, det1, det2).
#' Note that if param is of length 3, then detparam must be supplied. See obsfun0, procfun0, and detfun0 for more details.
#' @param detparam Optional vector of length two, including paramters for the mean coloniztion abundance and the deterministic function.
#' @keywords stability, time-series, particle filter
#' @return a formatted list of parameters
#' @export

parseparam0<-function(param, detparam=c(log(0.01), log(3),log(1))) {
  if(length(param)==3) {
    pars<-list(obs=c(param[1]),
               proc=c(param[2]),
               pcol=c(param[3], detparam[1]),
               det=detparam[c(2:3)])
  } else if(length(param)==6) {
    pars<-list(obs=c(param[1]),
               proc=c(param[2]),
               pcol=c(param[3:4]),
               det=c(param[5:6]))
  } else {
    return("error: param must be either length 3 or 6")
  }

  return(pars)
}


#' Default likelihood function
#'
#' Calculates likelihood of vector y given parameter values in param, based on the particleFilterLL function.
#' @param param An unformatted vector of parameters, to be passed to parseparam function.
#' @param y A numeric vector of observed values, from which the likelihood of parameters and functions will be determined.
#' @param parseparam A function for transforming the vector param into a form that can be read by particleFilterLL. See particleFilterLL for details.
#' @param N Number of particles to simulate. Defaults to 1e3.
#' @param detfun A function that simulates deterministic dynamics, which takes in arguments sdet (parameters for deterministic model, taken from pars$proc), and xt, observed abundances at time t.
#' Returns estimated abundances at time t+1 based on deterministic function (either a parametric function or an EDM function). Defaults to detfun0.
#' @param edmdat A list including arguments to be passed to block_lnlp from rEDM package - see block_lnlp help file for details. Can also include optional matrix "extra_columns", a matrix with length(y) rows including extra covariates for attractor reconstruction, which defaults to NULL (i.e. no additional columns).
#' Default for edmdat is NULL, which implies that EDM will not be applied - instead, a detfun and pars$det must be included.
#' @keywords stability, time-series, MCMC optimization
#' @return Log likelihood generated by particleFilterLL function
#' @export

likelihood0 <- function(param, y=y, parseparam=parseparam0, N=1e3, detfun=detfun0, edmdat=NULL) {
  pars<-parseparam(param)

  tmp<-particleFilterLL(y, pars, N=N, detfun = detfun, edmdat = edmdat)
  tmp$LL
}


#' Get inverse logit-normal mode
#'
#' Returns a mean for a logit normal such that the mode will be centered around mu
#' @param mu the value around which the mode should be centered (in logit space)
#' @param sd the standard deviation of the logit distribution (in logit space)
#' @keywords MCMC optimization
#' @return the proposed mean for the distribution
#' @export

logitnormal_imode = function(mu, sd){
  mode<-mu - (sd)^2*(2*ilogit(mu)-1)
  return(mode)
}


#' Get inverse log-normal mode
#'
#' Returns a mean for a lognormal such that the mode will be centered around mu
#' @param mu the value around which the mode should be centered (in log space)
#' @param sd the standard deviation of the lognormal distribution (in log space)
#' @keywords MCMC optimization
#' @return the proposed mean for the distribution
#' @export

lognormal_imode = function(mu, sd){
  mode<-mu+sd^2
  return(mode)
}


#' Default density function for prior
#'
#' Default density function, following the syntax for priors in the BayesianTools package. Uses
#' lognormal priors for the observation error and process noise functions, and a logit-normal prior
#' for colonization probability. Optionally, values for mean colonization abundance, r, and K,
#' can be included (also in log space).
#' Note that prior likelihood is calculated based on values of param, which are centered around the listed values in variable pars.
#' @param param a vector of length 3 or 6 with mean model parameters
#' @param pars a list of parameter values, structured following the parseparam0 function, specifying the means for the priors
#' @param priorsd a vector of length 3 or 6 with desired standard deviations for the prior distributions
#' @keywords stability, time-series, MCMC optimization
#' @return returns log likelihood of parameters given priors.
#' @export

density_fun0 = function(param, pars=pars, priorsd=c(1, 1, 1)){
  dsum = dnorm(param[1], mean = pars$obs[1], sd =  priorsd[1], log = TRUE)
  dsum = dsum+dnorm(param[2], mean = pars$proc[1], sd = priorsd[2], log = TRUE)
  dsum = dsum+dnorm(param[3], mean = pars$pcol[1], sd = priorsd[3], log = TRUE)

  if(length(param)==6) {
    dsum = dsum+dnorm(param[4], mean = pars$pcol[2], sd = priorsd[4], log = TRUE)
    dsum = dsum+dnorm(param[5], mean = pars$det[1], sd = priorsd[5], log = TRUE)
    dsum = dsum+dnorm(param[6], mean = pars$det[2], sd = priorsd[6], log = TRUE)
  }

  return(dsum)
}


#' Default sampler function for prior
#'
#' Text...
#' @param n number of random draws to take from the priors
#' @param pars a list of parameter values, structured following the parseparam0 function, specifying the centers for the priors
#' @param priorsd a vector of length 3 or 6 with desired standard deviations for the prior distributions
#' @param minv Vector of minimum values to return - defaults to rep(-6.9,3)
#' @param maxv Vector of maximum values to return - defaults to rep(2.9,3)
#' @keywords stability, time-series, MCMC optimization
#' @return returns random draws from the priors
#' @import stats
#' @export

sampler_fun0 = function(n=1, pars=pars, priorsd=c(1, 1, 1),
                        minv=c(rep(-6.9,3)),
                        maxv=c(rep(2.9,3))){

  if(!is.null(dim(priorsd)) && all.equal(nrow(priorsd), ncol(priorsd), length(pars))) {
    prl<-rmvnorm(n, pars, priorsd)
    d1 = prl[,1]
    d2 = prl[,2]
    d3 = prl[,3]
  } else {
    d1 = rnorm(n, mean = pars$obs[1], sd = priorsd[1])
    d2 = rnorm(n, mean = pars$proc[1], sd = priorsd[2])
    d3 = rnorm(n, mean = pars$pcol[1], sd=priorsd[3])
  }

  d1[d1<minv[1]]<-minv[1]; d1[d1>maxv[1]]<-maxv[1]
  d2[d2<minv[2]]<-minv[2]; d2[d2>maxv[2]]<-maxv[2]
  d3[d3<minv[3]]<-minv[3]; d3[d3>maxv[3]]<-maxv[3]

  if(length(priorsd)==6) {
    if(!is.null(dim(priorsd)) && all.equal(nrow(priorsd), ncol(priorsd), length(pars))) {
      d4 = prl[,4]
      d5 = prl[,6]
      d6 = prl[,6]
    } else {
      d4 = rnorm(n, mean = pars$pcol[2], sd=priorsd[4])
      d5 = rnorm(n, mean = pars$det[1], sd=priorsd[5])
      d6 = rnorm(n, mean = pars$det[2], sd=priorsd[6])
    }

    d4[d4<minv[4]]<-minv[4]; d4[d7>maxv[4]]<-maxv[4]
    d5[d5<minv[5]]<-minv[5]; d5[d7>maxv[5]]<-maxv[5]
    d6[d6<minv[6]]<-minv[6]; d6[d8>maxv[6]]<-maxv[6]

    return(cbind(d1,d2,d3,d4,d5,d6))
  } else {
    return(cbind(d1,d2,d3))
  }
}


#' Default inverse transormation function
#'
#' Takes in a matrix, where each column represents a parameter. Returns parameters in untransformed space.
#' @param x an nxm matrix with
#' @keywords stability, time-series, MCMC optimization
#' @return returns back-transformed values of parameters
#' @export

inv_fun0<-function(x) {
  if(ncol(x)==3) {
    cbind(exp(x[,1]), exp(x[,2]), ilogit(x[,3]))
  } else {
    cbind(exp(x[,1]), exp(x[,2]), ilogit(x[,3]), exp(x[,4]), exp(x[,5]), exp(x[,6]))
  }
}


#' Approximate Bayesian Computation-based optimizer
#'
#' Attempts to find maximum likelihood parameter estimates for parameter set p0 and
#' associated models, given observed time-series y. Can be used to either run a new
#' optimization routine, or to extend an existing run to include more iterations.
#' @param y Observed values, against which model likelihood will be estimated. No default is included, though the value can be taken from 'oldrun' if provided.
#' @param p0 Initial mean values for each parameter to be estimated. Used to sample first sets of values for the optimizer, and to parameterize the prior. No default is included, though the value can be taken from 'oldrun' if provided.
#' @param sd0 Initial standard deviation for each parameter in 'p0'. Used to sample first sets of values for the optimizer, and to parameterize the prior. Defaults to 1 for every parameter.
#' @param N Number of particle to use for the particle filter - passed to 'likelihood' function. Defaults to 1e3.
#' @param niter_optim Number of optimizer iterations to perform. Defaults to 20. Note, iterations can be extended post-hoc.
#' @param niter_pars Number of parameter sets to test per iteration. Defaults to 100.
#' @param fretain Optimizer retains fraction 'fretain' parameter sets with the highest likelihoods in each iteration, and uses these to update the values passed to 'sampler_fun'. Defaults to 0.1.
#' @param burnin Number of iterations to burn-in, during which initial values p0 and sd0 are passed to 'the 'sampler_fun'. Defaults to 2.
#' @param priorLL Should the likelihood of the parameters under the prior be added to the likelihood used for optimization? Can be useful when fitting models with hyperparameters, or if there is high uncertainty. Defaults to FALSE.
#' @param oldrun The output of a previous run of the run_ABC_optim function. If included, then this funciton extends that run. Any parameters with user-defined values NULL will take their values from this previous run, with two expetions:
#' burnin defaults to zero, and niter_pars will always be taken from the previous run, regardless of user input.
#' @param sampler_fun A function that can sample new values for the optimizer. Must be able to take two types of input -
#' either a vector of means and standard deviations, or a vector of means and a covariance matrix. See sampler_fun0 (default) for details.
#' @param parseparam A function for parsing a vector of parameters into a form that is readable by the likelihood function. Defaults to parseparam0.
#' @param likelihood A function that returns log likelihood estimates of the observed data given some model (e.g. a particle filter). See likelihood0 (default) for examples.
#' @param density_fun A function that returns log likelihood estimates for parameter p0 given prior estimates of mean and standard deviation. Defaults to density_fun0. Is used to calculate likelihood under the prior, if requested.
#' @param bootstrap_subs Should the 'fretain' best observations be bootstrapped (with replacement) before moving to the next iteration? Can help prevent outliers from dominating optimization. Defaults to TRUE.
#' @param report_interval How frequently should progress be reported? Defaults to the minimum of every 10 iterations, or 1/10 of the total number of iterations.
#' @param silent If FALSE (default), then progress is reported.
#' @keywords ABC optimization
#' @return Returns a list, including mean parameter and likelihood values
#' for each iteration (parsmean and LLmean), an apporoximation of the
#' covariance matrix relating parameters (parscv), the full information for
#' likelihood and parameter estimates for each iteration (LLout and parout),
#' and a list of the parameters used to run the model (runstats).
#'
#' @import mvtnorm
#' @export

run_ABC_optim<-function(y=NULL,
                        p0=NULL, sd0=NULL, N=NULL,
                        niter_optim=NULL, niter_pars=NULL,
                        fretain=NULL, burnin=NULL, priorLL=NULL,
                        oldrun = NULL,
                        sampler_fun=NULL, parseparam=NULL, likelihood=NULL, density_fun=NULL,
                        bootstrap_subs=NULL,
                        report_interval=pmin(round(niter_optim/10), 10),
                        silent=FALSE) {

  ## get parameter values from old run, if applicable, or enter default values
  if(is.null(oldrun)) {
    if(is.null(y) | is.null(p0)) {
      return("error: y and p0 must be provided, either directly or via variable 'oldrun'")
    }
  } else {
    if(is.null(y)) {
      y<-oldrun$runstats$y
    }
    if(is.null(p0)) {
      p0<-oldrun$runstats$p0
    }
  }
  npars<-length(p0) #number of parameters

  if(is.null(sd0)) {
    if(is.null(oldrun)) {
      sd0<-rep(1, length(p0))
    } else {
      sd0<-oldrun$runstats$sd0
    }
  }
  if(is.null(N)) {
    if(is.null(oldrun)) {
      N<-1e3
    } else {
      N<-oldrun$runstats$N
    }
  }
  if(is.null(niter_optim)) {
    if(is.null(oldrun)) {
      niter_optim<-20
    } else {
      niter_optim<-oldrun$runstats$niter_optim
    }
  }
  if(is.null(oldrun)) {
    if(is.null(niter_pars)) {
      niter_pars<-100
    }
  } else {
    #niter_pars must match that from previous run
    niter_pars<-oldrun$runstats$niter_pars
  }
  if(is.null(fretain)) {
    if(is.null(oldrun)) {
      fretain<-0.1
    } else {
      fretain<-oldrun$runstats$fretain
    }
  }
  if(is.null(burnin)) {
    if(is.null(oldrun)) {
      burnin<-2
    } else {
      #defaults to no burnin if extending an old run
      burnin<-0
    }
  }
  if(is.null(priorLL)) {
    if(is.null(oldrun)) {
      priorLL<-FALSE
    } else {
      priorLL<-oldrun$runstats$priorLL
    }
  }
  if(is.null(sampler_fun)) {
    if(is.null(oldrun)) {
      sampler_fun<-sampler_fun0
    } else {
      sampler_fun<-oldrun$runstats$sampler_fun
    }
  }
  if(is.null(parseparam)) {
    if(is.null(oldrun)) {
      parseparam<-parseparam0
    } else {
      parseparam<-oldrun$runstats$parseparam
    }
  }
  if(is.null(likelihood)) {
    if(is.null(oldrun)) {
      likelihood<-likelihood0
    } else {
      likelihood<-oldrun$runstats$likelihood
    }
  }
  if(is.null(density_fun)) {
    if(is.null(oldrun)) {
      density_fun<-density_fun0
    } else {
      density_fun<-oldrun$runstats$density_fun
    }
  }
  if(is.null(bootstrap_subs)) {
    if(is.null(oldrun)) {
      bootstrap_subs<-TRUE
    } else {
      bootstrap_subs<-oldrun$runstats$bootstrap_subs
    }
  }

  ## set up output matrices
  #initial draw of parameters
  if(is.null(oldrun)) {
    prl<-(sampler_fun(n=niter_pars, pars=parseparam(p0), priorsd = sd0))
  } else {
    prl<-sampler_fun(niter_pars, oldrun$parsmean[nrow(oldrun$parsmean),], oldrun$parscv[nrow(oldrun$parsmean),,])
  }
  #likelihood
  LLout<-matrix(nrow=niter_optim, ncol=niter_pars)
  if(!is.null(oldrun)) {
    LLout<-rbind(oldrun$LLout, LLout)
  }
  #parameters
  if(!is.null(oldrun)) {
    parout<-array(dim=c(niter_optim+oldrun$runstats$niter_optim, niter_pars, npars))
    parout[1:oldrun$runstats$niter_optim,,]<-oldrun$parout
  } else {
    parout<-array(dim=c(niter_optim, niter_pars, npars))
  }
  #mean outputs
  LLmean<-numeric(niter_optim)
  if(!is.null(oldrun)) {
    LLmean<-c(oldrun$LLmean, LLmean)
  }
  parsmean<-matrix(nrow=niter_optim, ncol=npars)
  if(!is.null(oldrun)) {
    parsmean<-rbind(oldrun$parsmean, parsmean)
  }

  #covariance matrix
  if(!is.null(oldrun)) {
    parscv<-array(dim=c(niter_optim+oldrun$runstats$niter_optim, npars, npars))
    parscv[1:oldrun$runstats$niter_optim,,]<-oldrun$parscv
  } else {
    parscv<-array(dim=c(niter_optim,npars, npars))
  }

  ## find optimal parameters
  if(!is.null(oldrun)) {
    ifrom<-oldrun$runstats$niter_optim+1
    ito<-ifrom+niter_optim-1
    burnin_use<-burnin+ifrom-1
  } else {
    ifrom<-1
    ito<-niter_optim
    burnin_use<-burnin
  }

  for(i in ifrom:ito) {
    #run filter for each parameter set
    out<-apply(prl, 1, function(x) likelihood0(x, y=y, parseparam = parseparam0, N=1e3))

    #save outputs
    LLout[i,]<-out
    parout[i,,]<-prl

    #include prior in likelihood calculation?
    if(priorLL) {
      #likelihood of parameters under the prior
      LL_prior<-apply(prl, 1, function(x) density_fun(x, parseparam(p0), sd0))
      LLout[i,]<-LLout[i,]+LL_prior
    }

    #get weights for fraction "fretain" best parameter sets
    sbs<-which(LLout[1:i,]>quantile(LLout[1:i,], 1-fretain))
    if(bootstrap_subs) {
      sbs<-sample(sbs, length(sbs), replace = TRUE)
    }

    pd<-exp(LLout[1:i,][sbs]-max(LLout[1:i,][sbs]))/sum(exp(LLout[1:i,][sbs]-max(LLout[1:i,][sbs]))) #calculate weights

    #calculate weighted mean and variance/covariance
    mu_est<-numeric(npars)
    cvmat_est<-matrix(nrow=npars, ncol=npars)
    for(ii in 1:npars) {
      mu_est[ii]<-sum(parout[1:i,,ii][sbs]*pd)
      cvmat_est[ii,ii]<-sum(((parout[1:i,,ii][sbs]-mu_est[ii])^2)*pd*(1-sum(pd^2)/(sum(pd)^2)))
      for(jj in (ii+1):npars) {
        if(jj<=npars) {
          cvmat_est[ii,jj]<-cvmat_est[jj,ii]<-sum(((parout[1:i,,ii][sbs]-mu_est[ii])*
                                                     (parout[1:i,,jj][sbs]-mu_est[jj]))*pd)*
            (1/(1-sum(pd^2)))
        }
      }
    }

    #generate new parameter set
    if(i>=burnin_use) {
      prl<-sampler_fun(niter_pars, mu_est, cvmat_est)
    } else {
      prl<-sampler_fun(n=niter_pars, pars=parseparam(p0))
    }

    #save outputs
    parsmean[i,]<-mu_est
    parscv[i,,]<-cvmat_est
    LLmean[i]<-mean(LLout[1:i,][sbs])

    #report progress
    if(!silent) {
      if(i==ifrom) {
        cat("progress:")
      }
      if(i/report_interval == floor(i/report_interval)) {
        cat(paste("..", 100*round((i-ifrom+1)/(ito-ifrom+1),ceiling(log10(niter_optim))), "%", sep=""))
      }
    }
  }

  #save original burnin value
  if(!is.null(oldrun)) {
    burnin<-oldrun$runstats$burnin
  }

  #return output
  return(list(#summary data
    parsmean=parsmean, parscv=parscv, LLmean=LLmean,
    #full data
    LLout=LLout, parout=parout,
    #data needed for extending a run
    runstats=list(y=y,p0=p0, sd0=sd0,N=N,
                  niter_optim=niter_optim, niter_pars=niter_pars,
                  fretain=fretain, burnin=burnin, priorLL=priorLL,
                  sampler_fun=sampler_fun,
                  parseparam=parseparam,
                  likelihood=likelihood,
                  density_fun=density_fun,
                  bootstrap_subs=bootstrap_subs)))
}


#' Plot likelihoods from optimization
#'
#' Plots the change in log likelihood across simulations based on an output from the run_ABC_optim function.
#' @param optout Output from the run_ABC_optim function.
#' @param logx Should the x-axis (number of iterations) be plotted in log space? Defaults to FALSE.
#' @keywords ABC optimization
#' @return a plot
#' @export

plot_abc_likelihood<-function(optout, logx=FALSE) {
  if(logx) {
    tmp<-"x"
  } else {
    tmp<-""
  }
  plot(optout$LLmean, type="l", xlab="iteration", ylab="LL", log = tmp, lwd=2)
  abline(v=optout$runstats$burnin, lty=2)
}


#' Plot rmse of parameter estimates
#'
#' Plots the root mean square error of the optimizer over iterations, if true parameter values are known a prior (e.g. to test settings on simulated data).
#' @param optout Output from the run_ABC_optim function.
#' @param param_true A vector containing the "true" parameter values.
#' @param doLL Should rmse also be plotted alongside log likelihood? Defaults to TRUE.
#' @keywords ABC optimization
#' @return a plot
#' @export

plot_abc_rmse<-function(optout, param_true, doLL=TRUE) {
  rmse<-colSums((t(optout$parsmean)-param_true)^2)
  plot(rmse, type="l", xlab="iteration", ylab="rmse", lwd=2)

  if(doLL) {
    plot(rmse, optout$LLmean, xlab="rmse", ylab="LL", log="x")
    mod<-loess(optout$LLmean~log(rmse), enp.target = 5)
    sq<-seq(min(rmse), max(rmse), length=1000)
    lines(sq, predict(mod, newdata=data.frame(rmse=sq)), lwd=2)
  }
}


#' Plot parameter estimates from optimization
#'
#' Plots the change in parameter estimates over the course of optimization. Shows mean, confidence interval, and (optionally) positions of true values and priors.
#' @param optout Output from the run_ABC_optim function.
#' @param ifun A list of inverse functions to be applied to the parameters for plotting - defaults to no tranformation.
#' @param param0 An optional vector of prior values for the paramters, to be plotted in blue.
#' @param param_true An optional vector of true values for parameters, to be plotted in red.
#' @param alpha Confidence interval size to be plotted for the parameter estimates. Defaults to 0.95.
#' @keywords ABC optimization
#' @return a plot
#' @export

plot_abc_params<-function(optout, ifun=list(function(x) {x}), param0=NULL, param_true=NULL, alpha=0.95) {
  np<-length(optout$runstats$p0)
  if(length(ifun)==1 && np > 1) {
    for(i in 2:np) {
      ifun[[i]]<-ifun[[1]]
    }
  }

  for(i in 1:np) {
    xv<-optout$parsmean[,i]+qnorm(1-(1-alpha)/2)*cbind(-sqrt(optout$parscv[,i,i]), 0, sqrt(optout$parscv[,i,i]))

    matplot(1:nrow(optout$parsmean), ifun[[i]](xv),
            type="l", col=1, lty=c(2,1,2),
            xlab="iterations", ylab=names(param0[i]),
            ylim=ifun[[i]](range(c(xv, param_true[i], param0[i]))), lwd=c(1,2,1))
    if(!is.null(param_true)) {
      abline(h=ifun[[i]](param_true[i]), lty=3, col=2)
    }
    if(!is.null(param0)) {
      abline(h=ifun[[i]](param0[i]), lty=3, col=4)
    }
  }
}


#' Estimate parameter distribution from likelihood density function.
#'
#' Extracts (and optionally plots) information from the density function generated across runs in the run_ABC_optim function.
#' Calculates estimates of the mean and standard deviation of parameters from this distribution, based on weighted averaging
#' @param optout Output from the run_ABC_optim function.
#' @param param0 An optional vector of prior values for the paramters, to be plotted in blue.
#' @param param_true An optional vector of true values for parameters, to be plotted in red.
#' @param fretain Retain fraction 'fretain' parameter estiamtes with the highest likelihoods from the optimization process for subsequent calculations
#' @param enp.target Smoothing parameter, passed to loess function for estimating density function. Defaults to 5. Note - numbers closer to zero generally yield smoother, but less detailed, estimates.
#' @param sm_steps Number of steps to estimate from the smoother for calculating means and standard deviations. Defaults to 1000.
#' @param pltnames Names to be included in plots. Defaults to names(param0).
#' @param doplot Should the distributions be plotted? Defaults to TRUE.
#' @keywords ABC optimization
#' @return A list including mean parameter values (muest) and standard deviations for parameter values (sdest) calculated from the density function. These
#' are probably the best estimates to report and use for subsequent analysis, as the covariance outputs from the optimizer are generally too small as a result
#' of the range of space that is sampled by 'sampler_fun'. Optionally also plots the density point estimates and kernel smoother -
#' note that smoothed function is plotted higher above the points than it actually appears, for better visualization.
#' @export

abc_densities<-function(optout, param0=NULL, param_true=NULL, fretain=NULL, enp.target=5, sm_steps=1000, pltnames=names(param0), doplot=TRUE) {
  if(is.null(fretain)) {
    fretain<-optout$runstats$fretain
  }
  nparm<-length(optout$runstats$p0)
  muest<-numeric(nparm)
  sdest<-numeric(nparm)

  if(length(enp.target)==1) {
    enp.target<-rep(enp.target, nparm)
  }

  for(i in 1:nparm) {
    tmp<-optout$parout[,,i]
    ps<-which(optout$LLout>quantile(optout$LLout,1-fretain))

    if(doplot) {
      plot(tmp[ps], c(optout$LLout)[ps],
           main=pltnames[i],
           xlab="parameter", ylab="LL", cex=0.5,
           xlim=range(c(tmp[ps], param0[i], param_true[i])))
      if(!is.null(param0)) {
        abline(v=c(param0[i]), lty=2, lwd=2, col=4)
      }
      if(!is.null(param_true)) {
        abline(v=c(param_true[i]), lty=2, lwd=2, col=2)
      }
    }

    xtmp<-tmp[ps]
    ytmp<-optout$LLout[ps]
    wts<-exp(ytmp-max(ytmp))/sum(exp(ytmp-max(ytmp)))
    mod<-loess(ytmp~xtmp, weights = wts, enp.target = enp.target[i])
    sq<-seq(min(xtmp), max(xtmp), length=sm_steps)
    pred<-predict(mod, newdata=data.frame(xtmp=sq))

    if(doplot) {
      par(new=TRUE)
      plot(sq, pred, col=3, lwd=2,
           xlim=range(c(tmp[ps], param0[i], param_true[i])),
           axes=F, xlab="", ylab="", type="l")
    }

    wts<-exp(pred-max(pred))/sum(exp(pred-max(pred)))

    muest[i]<-sum(sq*wts)
    sdest[i]<-sqrt(sum(((sq-muest[i])^2)*wts*(1-sum(wts^2)/(sum(wts)^2))))
  }

  return(list(muest=muest, sdest=sdest))
}


#' Coerce p-value to fall into lower tail.
#'
#' Returns either x, or 1-x, whichever is smaller.
#' @param x The value to be transformed
#' @keywords helper function
#' @return The lower-tail probability estimate
#' @export

lowertail<-function(x) {pmin(x, 1-x)}


