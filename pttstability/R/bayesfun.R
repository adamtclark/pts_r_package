#' Parse parameters
#'
#' Takes in a vector of 3 or 6 parameters, and puts them into a list of the format expected by the particleFilterLL function.
#' @param param List of 3 or 6 paramters, in the order (obs1, proc1, pcol1, pcol2, det1, det2).
#' Note that if param is of length 3, then detparam must be supplied. See obsfun0, procfun0, and detfun0 for more details.
#' @param detparam Optional vector of length two, including paramters for the mean coloniztion abundance and the deterministic function.
#' @keywords stability, time-series, particle filter
#' @return a formatted list of parameters
#' @export

parseparam0<-function(param, detparam=c(log(0.01), log(3),log(1))) {
  if(is.null(dim(param))) { # only one set of parameters to estimate
    if(length(param)==3) {
      pars<-list(obs=c(param[1]),
                 proc=c(param[2]),
                 pcol=c(param[3], detparam[1]),
                 det=detparam[c(2:3)])
    } else if(length(param)==6) {
      pars<-list(obs=c(param[1]),
                 proc=c(param[2]),
                 pcol=c(param[3:4]),
                 det=c(param[5:6]))
    } else {
      return("error: param must be either length 3 or 6")
    }
  } else { # one set of parameters per row in param
    #multivariate

    if(ncol(param)==3) {
      pars<-list(obs=param[,1,drop=FALSE],
                 proc=param[,2,drop=FALSE],
                 pcol=cbind(param[,3,drop=FALSE], detparam[1]),
                 det=t(matrix(nrow=2, ncol=nrow(param), data=detparm)))
    } else if(ncol(param)==6) {
      pars<-list(obs=c(param[,1,drop=FALSE]),
                 proc=c(param[,2,drop=FALSE]),
                 pcol=c(param[,3:4,drop=FALSE]),
                 det=c(param[,5:6,drop=FALSE]))
    } else {
      return("error: param must include either 3 or 6 parameters")
    }
  }

  return(pars)
}


#' Default likelihood function
#'
#' Calculates likelihood of vector y given parameter values in param, based on the particleFilterLL function.
#' @param param An unformatted vector of parameters, to be passed to parseparam function.
#' @param y A numeric vector of observed values, from which the likelihood of parameters and functions will be determined.
#' @param parseparam A function for transforming the vector param into a form that can be read by particleFilterLL. See particleFilterLL for details.
#' @param N Number of particles to simulate. Defaults to 1e3.
#' @param detfun A function that simulates deterministic dynamics, which takes in arguments sdet (parameters for deterministic model, taken from pars$proc), and xt, observed abundances at time t.
#' Returns estimated abundances at time t+1 based on deterministic function (either a parametric function or an EDM function). Defaults to detfun0.
#' @param edmdat A list including arguments to be passed to block_lnlp from rEDM package - see block_lnlp help file for details. Can also include optional matrix "extra_columns", a matrix with length(y) rows including extra covariates for attractor reconstruction, which defaults to NULL (i.e. no additional columns).
#' Default for edmdat is NULL, which implies that EDM will not be applied - instead, a detfun and pars$det must be included.
#' @keywords stability, time-series, MCMC optimization
#' @return Log likelihood generated by particleFilterLL function
#' @export

likelihood0 <- function(param, y=y, parseparam=parseparam0, N=1e3, detfun=detfun0, edmdat=NULL) {
  pars<-parseparam(param)

  tmp<-particleFilterLL(y, pars, N=N, detfun = detfun, edmdat = edmdat)
  tmp$LL
}


#' Get inverse logit-normal mode
#'
#' Returns a mean for a logit normal such that the mode will be centered around mu
#' @param mu the value around which the mode should be centered (in logit space)
#' @param sd the standard deviation of the logit distribution (in logit space)
#' @keywords MCMC optimization
#' @return the proposed mean for the distribution
#' @export

logitnormal_imode = function(mu, sd){
  mode<-mu - (sd)^2*(2*ilogit(mu)-1)
  return(mode)
}


#' Get inverse log-normal mode
#'
#' Returns a mean for a lognormal such that the mode will be centered around mu
#' @param mu the value around which the mode should be centered (in log space)
#' @param sd the standard deviation of the lognormal distribution (in log space)
#' @keywords MCMC optimization
#' @return the proposed mean for the distribution
#' @export

lognormal_imode = function(mu, sd){
  mode<-mu+sd^2
  return(mode)
}


#' Default density function for prior
#'
#' Default density function, following the syntax for priors in the BayesianTools package. Uses
#' lognormal priors for the observation error and process noise functions, and a logit-normal prior
#' for colonization probability. Optionally, values for mean colonization abundance, r, and K,
#' can be included (also in log space).
#' Note that prior likelihood is calculated based on values of param, which are centered around the listed values in variable pars.
#' @param param a vector of length 3 or 6 with mean model parameters
#' @param pars a list of parameter values, structured following the parseparam0 function, specifying the means for the priors
#' @param priorsd a vector of length 3 or 6 with desired standard deviations for the prior distributions
#' @keywords stability, time-series, MCMC optimization
#' @return returns log likelihood of parameters given priors.
#' @export

density_fun0 = function(param, pars=pars, priorsd=c(1, 1, 1)){
  dsum = dnorm(param[1], mean = pars$obs[1], sd =  priorsd[1], log = TRUE)
  dsum = dsum+dnorm(param[2], mean = pars$proc[1], sd = priorsd[2], log = TRUE)
  dsum = dsum+dnorm(param[3], mean = pars$pcol[1], sd = priorsd[3], log = TRUE)

  if(length(param)==6) {
    dsum = dsum+dnorm(param[4], mean = pars$pcol[2], sd = priorsd[4], log = TRUE)
    dsum = dsum+dnorm(param[5], mean = pars$det[1], sd = priorsd[5], log = TRUE)
    dsum = dsum+dnorm(param[6], mean = pars$det[2], sd = priorsd[6], log = TRUE)
  }

  return(dsum)
}


#' Default sampler function for prior
#'
#' Text...
#' @param n number of random draws to take from the priors
#' @param pars a list of parameter values, structured following the parseparam0 function, specifying the centers for the priors
#' @param priorsd a vector of length 3 or 6 with desired standard deviations for the prior distributions
#' @param minv Vector of minimum values to return - defaults to rep(-6.9,3)
#' @param maxv Vector of maximum values to return - defaults to rep(2.9,3)
#' @keywords stability, time-series, MCMC optimization
#' @return returns random draws from the priors
#' @import stats
#' @export

sampler_fun0 = function(n=1, pars=pars, priorsd=c(1, 1, 1),
                        minv=c(rep(-6.9,3)),
                        maxv=c(rep(2.9,3))){
  d1 = rnorm(n, mean = pars$obs[1], sd = priorsd[1])
  d2 = rnorm(n, mean = pars$proc[1], sd = priorsd[2])
  d3 = rnorm(n, mean = pars$pcol[1], sd=priorsd[3])

  d1[d1<minv[1]]<-minv[1]; d1[d1>maxv[1]]<-maxv[1]
  d2[d2<minv[2]]<-minv[2]; d2[d2>maxv[2]]<-maxv[2]
  d3[d3<minv[3]]<-minv[3]; d3[d3>maxv[3]]<-maxv[3]

  if(length(priorsd)==6) {
    d4 = rnorm(n, mean = pars$pcol[2], sd=priorsd[4])
    d5 = rnorm(n, mean = pars$det[1], sd=priorsd[5])
    d6 = rnorm(n, mean = pars$det[2], sd=priorsd[6])

    d4[d4<minv[4]]<-minv[4]; d4[d7>maxv[4]]<-maxv[4]
    d5[d5<minv[5]]<-minv[5]; d5[d7>maxv[5]]<-maxv[5]
    d6[d6<minv[6]]<-minv[6]; d6[d8>maxv[6]]<-maxv[6]

    return(cbind(d1,d2,d3,d4,d5,d6))
  } else {
    return(cbind(d1,d2,d3))
  }
}


#' Default inverse transormation function
#'
#' Takes in a matrix, where each column represents a parameter. Returns parameters in untransformed space.
#' @param x an nxm matrix with
#' @keywords stability, time-series, MCMC optimization
#' @return returns back-transformed values of parameters
#' @export

inv_fun0<-function(x) {
  if(ncol(x)==3) {
    cbind(exp(x[,1]), exp(x[,2]), ilogit(x[,3]))
  } else {
    cbind(exp(x[,1]), exp(x[,2]), ilogit(x[,3]), exp(x[,4]), exp(x[,5]), exp(x[,6]))
  }
}
